<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>mysql的索引与优化 | Hawaii</title><meta name="author" content="华宜威"><meta name="copyright" content="华宜威"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、存储引擎1.1 MySQL体系结构 1). 连接层  最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql的索引与优化">
<meta property="og:url" content="https://hua-yiwei.github.io/2023/09/05/mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Hawaii">
<meta property="og:description" content="1、存储引擎1.1 MySQL体系结构 1). 连接层  最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hua-yiwei.github.io/imgs/article_cover/30.jpg">
<meta property="article:published_time" content="2023-09-05T03:55:33.000Z">
<meta property="article:modified_time" content="2024-02-06T06:31:35.336Z">
<meta property="article:author" content="华宜威">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hua-yiwei.github.io/imgs/article_cover/30.jpg"><link rel="shortcut icon" href="/imgs/logo.png"><link rel="canonical" href="https://hua-yiwei.github.io/2023/09/05/mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mysql的索引与优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-06 14:31:35'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/imgs/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/imgs/article_cover/30.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Hawaii"><span class="site-name">Hawaii</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mysql的索引与优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-05T03:55:33.000Z" title="发表于 2023-09-05 11:55:33">2023-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-06T06:31:35.336Z" title="更新于 2024-02-06 14:31:35">2024-02-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/mysql/">mysql</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.4k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="mysql的索引与优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1、存储引擎"><a href="#1、存储引擎" class="headerlink" title="1、存储引擎"></a>1、存储引擎</h1><h2 id="1-1-MySQL体系结构"><a href="#1-1-MySQL体系结构" class="headerlink" title="1.1 MySQL体系结构"></a>1.1 MySQL体系结构</h2><p><img src="/../imgs/image-20230905114950853.png"></p>
<p>1). 连接层 </p>
<p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所具有的操作权限。 </p>
<p>2). 服务层 </p>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<p> 3). 引擎层 </p>
<p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。 </p>
<p>4). 存储层 </p>
<p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p>
<h2 id="1-2-存储引擎介绍"><a href="#1-2-存储引擎介绍" class="headerlink" title="1.2 存储引擎介绍"></a>1.2 存储引擎介绍</h2><p>存储引擎是mysql数据库的核心，是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，理论来说，一个数据库的不同表可以使用不同的存储引擎，不过我们一般不会这么做。</p>
<p>目前MySQL支持多种存储引擎，可以使用如下命令查询MySQL支持的存储引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20230905153648547.png" alt="image-20230905153648547"></p>
<p>目前最主要存储引擎是InnoDB</p>
<h2 id="1-3-InnoDB"><a href="#1-3-InnoDB" class="headerlink" title="1.3 InnoDB"></a>1.3 InnoDB</h2><p>1). 介绍 </p>
<p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p>
<p>2). 特点 </p>
<ul>
<li>支持事务； </li>
<li>行级锁，提高并发访问性能； </li>
<li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li>
</ul>
<p>3). 文件</p>
<p>当一张表存储在一个文件中时，称为独立表空间</p>
<p>当多张表存储在一个文件中时，称为共享表空间</p>
<p>当使用独立表空间存储时，一张表对应一个xxx.ibd文件，xxx代表的是表名，这个.ibd文件保存了表的数据、结构和索引。文件存储在对应的数据库名称的文件下，如：</p>
<p><img src="/../imgs/image-20230905165627691.png" alt="image-20230905165627691"></p>
<p>这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一 个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi user.ibd</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20230905170601761.png" alt="image-20230905170601761"></p>
<p><img src="/../imgs/image-20230905170719613.png" alt="image-20230905170719613"></p>
<p>当使用共享表空间存储时，表数据都存储在ibdata1文件中。</p>
<p><img src="/../imgs/image-20230905165659863.png" alt="image-20230905165659863"></p>
<p>可以通过以下sql查看MySQL是使用独立表空间还是共享表空间</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20230905155726397.png" alt="image-20230905155726397"></p>
<p>当value是ON时，是独立表空间，这也是MySQL默认的值。当value是OFF时，则是共享表空间</p>
<p>也可以手动设置为共享表空间</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_file_per_table<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>此时再进行查询，结构如下：</p>
<p><img src="/../imgs/image-20230905160948810.png" alt="image-20230905160948810"></p>
<p>扩展：</p>
<p>在MySQL8以前，使用.frm 文件存储表的结构和定义，包括表的列名、数据类型、索引等信息。在MySQL8后，使用sdi序列化的数据字典—-&gt; 每个表的表空间自行管理json格式的私有数据字典信息，用来替换.frm。这个更改是为了提高数据字典的性能和可扩展性，并简化MySQL系统表的管理。</p>
<p>4). 逻辑存储结构</p>
<p><img src="/../imgs/d767260d990f4dc7a49f4664add2caa5.png" alt="img"></p>
<ul>
<li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。 </li>
<li>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 </li>
<li>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。 </li>
<li>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 </li>
<li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。</li>
</ul>
<h1 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h1><h2 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h2><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。</p>
<p><img src="/../imgs/image-20230906160138916.png" alt="image-20230906160138916"></p>
<h2 id="2-2-索引举例"><a href="#2-2-索引举例" class="headerlink" title="2.2 索引举例"></a>2.2 索引举例</h2><p>这里有一张user表，表的结构和数据如下：</p>
<p><img src="/../imgs/image-20230906163315958.png" alt="image-20230906163315958"></p>
<p>假如我们要执行的SQL语句为 ： <code>select * from user where age = 45;</code></p>
<p>1). 无索引情况</p>
<p><img src="/../imgs/image-20230906165146617.png" alt="image-20230906165146617"></p>
<p>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为全表扫描，性能很低。</p>
<p>2). 有索引情况</p>
<p>如果我们针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建立一个二叉树的索引结构。</p>
<p><img src="/../imgs/image-20230907090946429.png" alt="image-20230907090946429"></p>
<p>此时我们在进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。</p>
<blockquote>
<p> 注：这里是假设索引结构是二叉树，仅仅是假设</p>
</blockquote>
<h2 id="2-3-索引结构"><a href="#2-3-索引结构" class="headerlink" title="2.3 索引结构"></a>2.3 索引结构</h2><h3 id="2-3-1-MySQL支持的索引结构"><a href="#2-3-1-MySQL支持的索引结构" class="headerlink" title="2.3.1 MySQL支持的索引结构"></a>2.3.1 MySQL支持的索引结构</h3><table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree 索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<blockquote>
<p>注： 我们平常所说的索引，如果没有特别指明，都是指B+树索引</p>
</blockquote>
<blockquote>
<p>数据结构可视化网站：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
</blockquote>
<h3 id="2-3-2-二叉树"><a href="#2-3-2-二叉树" class="headerlink" title="2.3.2 二叉树"></a>2.3.2 二叉树</h3><p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p>
<p><img src="/../imgs/image-20230907105444917.png" alt="image-20230907105444917"></p>
<p>但是，如果是按顺序插入的话，就会出现如下的情况：</p>
<p><img src="/../imgs/image-20230907105107996.png" alt="image-20230907105107996"></p>
<p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p>
<ul>
<li>顺序插入时，会形成一个链表，查询性能大大降低。 </li>
<li>大数据量情况下，层级较深，检索速度慢。</li>
</ul>
<h3 id="2-3-3-红黑树"><a href="#2-3-3-红黑树" class="headerlink" title="2.3.3 红黑树"></a>2.3.3 红黑树</h3><p>红黑树是对二叉树的平衡改进，通过给每个节点增加一个颜色标识，每个节点颜色不是黑色就是红色，按一定的规则进行位置安排就能控制以每个节点为根的最长路径不大于最短路径的二倍，从而控制树的整体高度。</p>
<p><img src="/../imgs/image-20230907110316681.png" alt="image-20230907110316681"></p>
<p>但是，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p>
<ul>
<li>大数据量情况下，层级较深，检索速度慢。</li>
</ul>
<h3 id="2-2-4-B-Tree"><a href="#2-2-4-B-Tree" class="headerlink" title="2.2.4 B-Tree"></a>2.2.4 B-Tree</h3><p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。 以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：</p>
<p><img src="/../imgs/image-20230907112905390.png" alt="image-20230907112905390"></p>
<blockquote>
<p>树的度数指的是一个节点的子节点个数。</p>
</blockquote>
<p>特点：</p>
<ul>
<li>5阶的B树，每一个节点最多存储4个key，对应5个指针。 </li>
<li>一旦节点存储的key数量到达5，就会裂变，<strong>中间元素向上分裂</strong>。 </li>
<li>在B树中，非叶子节点和叶子节点都会存放数据。</li>
</ul>
<h3 id="2-2-5-B-Tree"><a href="#2-2-5-B-Tree" class="headerlink" title="2.2.5 B+Tree"></a>2.2.5 B+Tree</h3><p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一 下其结构示意图：</p>
<p><img src="/../imgs/image-20230907114926882.png" alt="image-20230907114926882"></p>
<p>我们可以看到两部分： </p>
<ul>
<li>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。 </li>
<li>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</li>
</ul>
<p>B+Tree 与 B-Tree相比，主要有以下三点区别： </p>
<ul>
<li>所有的数据都会出现在叶子节点。 </li>
<li>叶子节点形成一个单向链表。 </li>
<li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li>
</ul>
<blockquote>
<p>B+树的链表设计有几个重要的优点和用途：</p>
<ol>
<li>范围查询效率高：由于叶子节点之间是按照顺序链接的，可以轻松地从一个叶子节点开始，按顺序遍历链表以获取一个范围内的所有数据。</li>
<li>节省磁盘I&#x2F;O：当执行范围查询时，如果叶子节点之间没有链表，数据库系统可能需要进行更多的磁盘读取操作以获取范围内的所有数据。而有了链表，只需顺序遍历链表，减少了随机磁盘I&#x2F;O，提高了查询性能。</li>
<li>便于维护：当插入或删除数据时，只需调整相邻叶子节点的链表指针，而不需要重新平衡整棵树。这降低了维护成本，使得B+树在高度动态的数据集中更具优势。</li>
<li>提供有序性：B+树的叶子节点是按顺序链接的，这使得B+树非常适合需要有序数据的应用场景，例如数据库索引。有序性对于某些查询操作和范围查询非常有用，可以减少排序操作的需求。</li>
<li>方便全盘扫描</li>
</ol>
</blockquote>
<p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p>
<p><img src="/../imgs/image-20230907121039757.png" alt="image-20230907121039757"></p>
<h2 id="2-4-索引分类"><a href="#2-4-索引分类" class="headerlink" title="2.4 索引分类"></a>2.4 索引分类</h2><h4 id="2-4-1-索引分类"><a href="#2-4-1-索引分类" class="headerlink" title="2.4.1 索引分类"></a>2.4.1 索引分类</h4><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引、空间索引。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建, 只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td>NORMAL</td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
<tr>
<td>空间索引</td>
<td>空间数据类型的索引，只能在MyISAM创建</td>
<td>可以有多个</td>
<td>SPATIAL</td>
</tr>
</tbody></table>
<h4 id="2-4-2-聚集索引-二级索引"><a href="#2-4-2-聚集索引-二级索引" class="headerlink" title="2.4.2 聚集索引&amp;二级索引"></a>2.4.2 聚集索引&amp;二级索引</h4><p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据</td>
<td>必须有,而且只 有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p>聚集索引选取规则:</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引。</li>
<li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。 </li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li>
</ul>
<p>聚集索引和二级索引的具体结构如下：</p>
<p><img src="/../imgs/image-20230907144624051.png" alt="image-20230907144624051"></p>
<ul>
<li>聚集索引的叶子节点下挂的是这一行的数据 。 </li>
<li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li>
</ul>
<p>接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。</p>
<p><img src="/../imgs/image-20230907145030584.png" alt="image-20230907145030584"></p>
<p>具体过程如下: </p>
<p>①. 由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值 10。 </p>
<p>②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。 </p>
<p>③. 最终拿到这一行的数据，直接返回即可。</p>
<blockquote>
<p>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p>
</blockquote>
<h4 id="2-4-3-主键索引B-树推导"><a href="#2-4-3-主键索引B-树推导" class="headerlink" title="2.4.3 主键索引B+树推导"></a>2.4.3 主键索引B+树推导</h4><p>我们已经知道，InnoDB最小的存储单位页的大小是16K，假设主键是bigint类型，长度8字节，指针长度固定6字节，一行数据大小为1K，忽略innoDB页中其他占用空间的部分(很小)，推导一下不同的树高能保存多少数据。</p>
<p>①. 当树高&#x3D;1时，此时使用一个叶子节点，因此可以存储的数据行数为：节点容量&#x2F;每行数据大小&#x3D;16K&#x2F;1K&#x3D;16（行）</p>
<p>②. 当树高&#x3D;2时，这时只有根节点和叶子节点，根节点中存放主键和指针，叶子节点存放数据。</p>
<p><img src="/../imgs/image-20230907155414175.png" alt="image-20230907155414175"></p>
<p>每个叶子节点可以存放的数据行数按照上面的计算为16行。</p>
<p>假设根节点总的指针数为n，总的主键数为n-1，一个指针占6个直接，一个主键占8个字节，这有：n*8+(n-1)<em>6&#x3D;16K，计算得n约为1170。也就是说，根节点有1170个指针，那么就有1170个叶子节点，因此，可以存储的总数据行数&#x3D;16</em>1170&#x3D;18720（行）</p>
<p>③. 当树高&#x3D;3时：</p>
<p><img src="/../imgs/image-20230907173916061.png" alt="image-20230907173916061"></p>
<p>按上述推算方式得出，树高&#x3D;3时，可以存放的数量行数&#x3D;单个叶子节点存放数据行数 X 非叶子节点指针数量 X 根节点指针数量 &#x3D; 16 X 1170 X 1170 &#x3D; 21902400（行）。也就是两千多万行。</p>
<h2 id="2-5-SQL性能分析"><a href="#2-5-SQL性能分析" class="headerlink" title="2.5 SQL性能分析"></a>2.5 SQL性能分析</h2><h4 id="2-5-1-SQL执行频率"><a href="#2-5-1-SQL执行频率" class="headerlink" title="2.5.1 SQL执行频率"></a>2.5.1 SQL执行频率</h4><p>MySQL 客户端连接成功后，通过 <code>show [session|global] status</code> 命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session 是查看当前会话 ;</span></span><br><span class="line"><span class="comment">-- global 是查询全局数据 ;</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20230907175447115.png" alt="image-20230907175447115"></p>
<h4 id="2-5-2-慢查询日志"><a href="#2-5-2-慢查询日志" class="headerlink" title="2.5.2 慢查询日志"></a>2.5.2 慢查询日志</h4><p>1). 开启sql的慢查询日志</p>
<p>MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%slow_query_log%&quot;</span><br></pre></td></tr></table></figure>

<p>查询结果如下：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>slow_query_log</td>
<td>OFF</td>
<td>ON开启，OFF关闭</td>
</tr>
<tr>
<td>slow_query_log_file</td>
<td>D:\software\mysql\mysql-8.0.34-winx64\data\DESKTOP-S8QB488-slow.log</td>
<td>慢查询日志位置</td>
</tr>
</tbody></table>
<p>手动设置开启慢查询日志</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="keyword">ON</span>;  # 设置开启<span class="keyword">sql</span>慢查询日志</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">0.001</span>;  # 设置<span class="number">0.001</span>s就算是慢<span class="keyword">sql</span></span><br></pre></td></tr></table></figure>

<p>然后运行一个sql，在对应的慢查询日志文件中查看到记录</p>
<p><img src="/../imgs/image-20230908161442684.png" alt="image-20230908161442684"></p>
<blockquote>
<p>手动设置开启慢sql日志，会在MySQL服务重启时失效，要永久设置的话，还是要在配置文件设置</p>
</blockquote>
<p>2). 使用druid的慢sql监控查看</p>
<p><img src="/../imgs/image-20230908155414301.png" alt="image-20230908155414301"></p>
<h4 id="2-5-3-profile详情"><a href="#2-5-3-profile详情" class="headerlink" title="2.5.3 profile详情"></a>2.5.3 profile详情</h4><p><code>show profiles</code> 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have_profiling</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20230908162057771.png" alt="image-20230908162057771"></p>
<p>查看开关是否已经打开，如果开关未打开，需要使用<code>set global profiling = 1;</code>进行打开</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@profiling</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20230908163911411.png" alt="image-20230908163911411"></p>
<p>打开开关后，可以使用以下sql查看sql的执行情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看每一条SQL的耗时基本情况</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"><span class="comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure>



<h4 id="2-5-4-explain查询执行计划"><a href="#2-5-4-explain查询执行计划" class="headerlink" title="2.5.4 explain查询执行计划"></a>2.5.4 explain查询执行计划</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接在select语句之前加上关键字 explain / desc</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 ;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20230911161815588.png" alt="image-20230911161815588"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</td>
</tr>
<tr>
<td>type</td>
<td>表示连接类型，性能由好到差的连接类型为system、const、eq_ref、ref、range、 index、all等</td>
</tr>
<tr>
<td>possible_key</td>
<td>显示可能应用在这张表上的索引，一个或多个</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引，如果为NULL，则没有使用索引</td>
</tr>
<tr>
<td>key_len</td>
<td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好</td>
</tr>
<tr>
<td>ref</td>
<td>显示索引的哪一列被使用了，有时候会是一个常量，表示哪些列或常量被用于用于查找索引列上的值</td>
</tr>
<tr>
<td>rows</td>
<td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的</td>
</tr>
<tr>
<td>filtered</td>
<td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好</td>
</tr>
</tbody></table>
<p>type字段：</p>
<ul>
<li><p>system: 查询只有少量数据的系统表，往往不需要进行磁盘IO</p>
</li>
<li><p>const: 查询条件是<strong>主键或者唯一索引</strong>等于常量。如<code>explain select * from user where id=1</code></p>
</li>
<li><p>eq_ref: 查询条件使用了<strong>主键或者唯一索引</strong>的等值查询。如<code>EXPLAIN SELECT u.*, ur.* FROM user_role ur LEFT JOIN user u ON u.id= ur.user_id</code>。这条sql要注意，使用user_role 作为驱动表，user查询的type才会是eq_ref。</p>
</li>
<li><p>ref: 查询条件使用了<strong>普通索引</strong>的等值查询。</p>
</li>
<li><p>range: 在<strong>索引</strong>上的范围查询。</p>
</li>
<li><p>index: 在索引上的全表扫描，要扫描索引上的全部数据，它仅比全表扫描快一点。</p>
</li>
<li><p>all: 全表扫描</p>
</li>
</ul>
<blockquote>
<p>拓展1：使用EXPLAIN+SHOW WARNINGS查看执行计划的拓展信息</p>
<p>如下例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> user_role);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS;</span><br></pre></td></tr></table></figure>

<p>输出的拓展信息为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	`test`.`<span class="keyword">user</span>`.`id` <span class="keyword">AS</span> `id`,</span><br><span class="line">	`test`.`<span class="keyword">user</span>`.`name` <span class="keyword">AS</span> `name`,</span><br><span class="line">	`test`.`<span class="keyword">user</span>`.`age` <span class="keyword">AS</span> `age` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	`test`.`<span class="keyword">user</span>` semi</span><br><span class="line">	<span class="keyword">JOIN</span> ( `test`.`user_role` ) </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	(</span><br><span class="line">	`test`.`<span class="keyword">user</span>`.`id` <span class="operator">=</span> `test`.`user_role`.`user_id`)</span><br></pre></td></tr></table></figure>

<p>可以看到，MySQL将子查询优化为了表的连接查询</p>
</blockquote>
<blockquote>
<p>拓展2：MySQL8.0.16引入了<code>EXPLAIN FORMAT=TREE</code>语法，在MySQL8.0.18又引入了<code>EXPLAIN ANALYZE</code>语法。两者的输出差不多，只是<code>EXPLAIN ANALYZE</code>多了执行实际，返回行数、循环次数等。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN ANALYZE</span><br><span class="line"><span class="keyword">SELECT</span> u.<span class="operator">*</span>, r.<span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` u</span><br><span class="line"><span class="keyword">JOIN</span> user_role ur <span class="keyword">ON</span> ur.user_id<span class="operator">=</span>u.id</span><br><span class="line"><span class="keyword">JOIN</span> role r <span class="keyword">ON</span> r.id<span class="operator">=</span>ur.role_id</span><br><span class="line"><span class="keyword">WHERE</span> u.name<span class="operator">=</span>&quot;张三&quot;;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> Nested loop <span class="keyword">inner</span> <span class="keyword">join</span>  (cost<span class="operator">=</span><span class="number">0.7</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.0148</span>.<span class="number">.0</span><span class="number">.0171</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Filter</span>: ((ur.user_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>) <span class="keyword">and</span> (ur.role_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>))  (cost<span class="operator">=</span><span class="number">0.35</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.0079</span>.<span class="number">.0</span><span class="number">.01</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Table</span> scan <span class="keyword">on</span> ur  (cost<span class="operator">=</span><span class="number">0.35</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.0065</span>.<span class="number">.0</span><span class="number">.0084</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> Single<span class="operator">-</span><span class="type">row</span> index lookup <span class="keyword">on</span> r <span class="keyword">using</span> <span class="keyword">PRIMARY</span> (id<span class="operator">=</span>ur.role_id)  (cost<span class="operator">=</span><span class="number">0.35</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.0053</span>.<span class="number">.0</span><span class="number">.0053</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回结果的阅读顺序为：</p>
<ol>
<li><p>从右到左：没有遇到并列的迭代器之前，都是从右边开始执行；</p>
</li>
<li><p>从上到下：遇到并列的迭代器，都是上边的先开始执行。</p>
<p>后面第3部分的多表连接有例子</p>
</li>
</ol>
</blockquote>
<h2 id="2-6-索引使用"><a href="#2-6-索引使用" class="headerlink" title="2.6 索引使用"></a>2.6 索引使用</h2><h4 id="2-6-1-最左前缀法则"><a href="#2-6-1-最左前缀法则" class="headerlink" title="2.6.1 最左前缀法则"></a>2.6.1 最左前缀法则</h4><h1 id="3、多表连接"><a href="#3、多表连接" class="headerlink" title="3、多表连接"></a>3、多表连接</h1><p>我们已经知道，当我们执行<code>select * from user where name=&quot;张三&quot;时</code>，执行方式是先到<code>name</code>索引去寻找“张三”的值，如果user表还有其他字段，就会回表查询聚集索引得到数据。那当进行多表查询时，执行方式又是如何的？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.<span class="operator">*</span>, r.<span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` u</span><br><span class="line"><span class="keyword">JOIN</span> user_role ur <span class="keyword">ON</span> ur.user_id<span class="operator">=</span>u.id</span><br><span class="line"><span class="keyword">JOIN</span> role r <span class="keyword">ON</span> r.id<span class="operator">=</span>ur.role_id</span><br><span class="line"><span class="keyword">WHERE</span> u.name<span class="operator">=</span>&quot;张三&quot;</span><br></pre></td></tr></table></figure>







<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>TREE</span><br><span class="line"><span class="keyword">SELECT</span> u.<span class="operator">*</span>, r.<span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` u</span><br><span class="line"><span class="keyword">JOIN</span> user_role ur <span class="keyword">ON</span> ur.user_id<span class="operator">=</span>u.id</span><br><span class="line"><span class="keyword">JOIN</span> role r <span class="keyword">ON</span> r.id<span class="operator">=</span>ur.role_id</span><br><span class="line"><span class="keyword">WHERE</span> u.name<span class="operator">=</span>&quot;张三&quot;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hua-yiwei.github.io">华宜威</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hua-yiwei.github.io/2023/09/05/mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96/">https://hua-yiwei.github.io/2023/09/05/mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hua-yiwei.github.io" target="_blank">Hawaii</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">华宜威</div><div class="author-info__description">Hawaii’s blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.</span> <span class="toc-text">1、存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 MySQL体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 存储引擎介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-InnoDB"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 InnoDB</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E7%B4%A2%E5%BC%95"><span class="toc-number">2.</span> <span class="toc-text">2、索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 索引概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%B4%A2%E5%BC%95%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 索引举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 MySQL支持的索引结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-B-Tree"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.2.4 B-Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-B-Tree"><span class="toc-number">2.3.5.</span> <span class="toc-text">2.2.5 B+Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">2.4.0.1.</span> <span class="toc-text">2.4.1 索引分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">2.4.0.2.</span> <span class="toc-text">2.4.2 聚集索引&amp;二级索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95B-%E6%A0%91%E6%8E%A8%E5%AF%BC"><span class="toc-number">2.4.0.3.</span> <span class="toc-text">2.4.3 主键索引B+树推导</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 SQL性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-SQL%E6%89%A7%E8%A1%8C%E9%A2%91%E7%8E%87"><span class="toc-number">2.5.0.1.</span> <span class="toc-text">2.5.1 SQL执行频率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">2.5.0.2.</span> <span class="toc-text">2.5.2 慢查询日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-profile%E8%AF%A6%E6%83%85"><span class="toc-number">2.5.0.3.</span> <span class="toc-text">2.5.3 profile详情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4-explain%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">2.5.0.4.</span> <span class="toc-text">2.5.4 explain查询执行计划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 索引使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">2.6.0.1.</span> <span class="toc-text">2.6.1 最左前缀法则</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text">3、多表连接</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/07/java/%E5%B8%B8%E7%94%A8%E7%B1%BB/Stream%E6%B5%81%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Stream流（二）"><img src="/imgs/article_cover/44.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Stream流（二）"/></a><div class="content"><a class="title" href="/2024/02/07/java/%E5%B8%B8%E7%94%A8%E7%B1%BB/Stream%E6%B5%81%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Stream流（二）">Stream流（二）</a><time datetime="2024-02-07T10:55:32.000Z" title="发表于 2024-02-07 18:55:32">2024-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/07/java/%E5%B8%B8%E7%94%A8%E7%B1%BB/Stream%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89/" title="Stream流（一）"><img src="/imgs/article_cover/19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Stream流（一）"/></a><div class="content"><a class="title" href="/2024/02/07/java/%E5%B8%B8%E7%94%A8%E7%B1%BB/Stream%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89/" title="Stream流（一）">Stream流（一）</a><time datetime="2024-02-07T00:55:32.000Z" title="发表于 2024-02-07 08:55:32">2024-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/06/java/%E5%B8%B8%E7%94%A8%E7%B1%BB/LocalDate%E7%B1%BB/" title="LocalDate类"><img src="/imgs/article_cover/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LocalDate类"/></a><div class="content"><a class="title" href="/2024/02/06/java/%E5%B8%B8%E7%94%A8%E7%B1%BB/LocalDate%E7%B1%BB/" title="LocalDate类">LocalDate类</a><time datetime="2024-02-06T00:55:32.000Z" title="发表于 2024-02-06 08:55:32">2024-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/20/MySQL/Windows%E4%B8%8A%E5%AE%89%E8%A3%85%E7%AC%AC%E4%BA%8C%E4%B8%AAMySQL/" title="Windows上安装第二个MySQL"><img src="/imgs/article_cover/27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows上安装第二个MySQL"/></a><div class="content"><a class="title" href="/2024/01/20/MySQL/Windows%E4%B8%8A%E5%AE%89%E8%A3%85%E7%AC%AC%E4%BA%8C%E4%B8%AAMySQL/" title="Windows上安装第二个MySQL">Windows上安装第二个MySQL</a><time datetime="2024-01-20T08:21:19.000Z" title="发表于 2024-01-20 16:21:19">2024-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/10/Linux/openVPN/openVPN%E5%81%9A%E4%BB%A3%E7%90%86/" title="openVPN做代理"><img src="/imgs/article_cover/44.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="openVPN做代理"/></a><div class="content"><a class="title" href="/2024/01/10/Linux/openVPN/openVPN%E5%81%9A%E4%BB%A3%E7%90%86/" title="openVPN做代理">openVPN做代理</a><time datetime="2024-01-10T03:50:42.000Z" title="发表于 2024-01-10 11:50:42">2024-01-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 华宜威</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>